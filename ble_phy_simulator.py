# -*- coding: utf-8 -*-
"""L1 PHY Simulator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kmbdT5CA75-IVYlr-3AlDvRZm3C2Rlub
"""

#
#  File: ble_phy_simulator.py
#  This module simulates the BLE Physical Layer (Layer 1).
#

import hashlib

# --- BLE Layer 1 (PHY) Constants ---
ACCESS_ADDRESS = b'\x8E\x89\xBE\xD6'  # (4 bytes)
PREAMBLE = b'\xAA'                   # (1 byte)
CRC_LENGTH = 16 # Using MD5 for simplicity

def create_phy_packet(pdu: bytes, verbose=False) -> bytes:
    """
    Simulates the Layer 1 "Modulator."
    Takes the Layer 2 PDU (data) and wraps it in a Layer 1 PHY packet frame.

    [PREAMBLE][ACCESS_ADDRESS][PDU_LENGTH][PDU][CRC]
    """

    pdu_length_byte = bytes([len(pdu)])

    # Calculate "CRC" (checksum) for the data
    crc = hashlib.md5(pdu_length_byte + pdu).digest()

    # Construct the full "raw" packet to be "transmitted"
    raw_packet = (
        PREAMBLE +
        ACCESS_ADDRESS +
        pdu_length_byte +
        pdu +
        crc
    )

    if verbose:
        print(f"  [L1 PHY] Wrapped PDU in L1 Frame. (Preamble, AA, CRC added)")
        print(f"    [L1] Raw Packet (hex): {raw_packet.hex()}")

    return raw_packet

def parse_phy_packet(raw_packet: bytes, verbose=False) -> bytes | None:
    """
    Simulates the Layer 1 "Demodulator."
    Parses a raw byte stream to find a valid PHY packet.

    Returns: The PDU (data) if the packet is valid, or None if it's corrupt.
    """

    try:
        if verbose:
            print(f"\n  [L1 PHY] Parsing {len(raw_packet)} raw bytes...")
            print(f"    [L1] Raw Data (hex): {raw_packet.hex()}")

        # 1. Check Preamble
        preamble = raw_packet[0:1]
        if preamble != PREAMBLE:
            if verbose: print("    [L1] REJECT: Bad Preamble.")
            return None

        # 2. Check Access Address
        access_addr = raw_packet[1:5]
        if access_addr != ACCESS_ADDRESS:
            if verbose: print("    [L1] REJECT: Bad Access Address.")
            return None

        # 3. Extract PDU Length
        pdu_length = raw_packet[5]

        # 4. Extract PDU and CRC
        pdu_start = 6
        pdu_end = pdu_start + pdu_length
        pdu = raw_packet[pdu_start:pdu_end]

        crc_start = pdu_end
        crc_end = crc_start + CRC_LENGTH
        received_crc = raw_packet[crc_start:crc_end]

        # 5. Validate CRC (the most important part of Layer 1)
        pdu_length_byte = bytes([pdu_length])
        expected_crc = hashlib.md5(pdu_length_byte + pdu).digest()

        if received_crc != expected_crc:
            if verbose: print("    [L1] REJECT: CRC Mismatch! Packet is corrupt.")
            return None

        if verbose:
            print("    [L1] ACCEPT: Packet OK. Passing PDU to Layer 2.")
            print(f"      [L1] Extracted PDU (hex): {pdu.hex()}")

        return pdu

    except IndexError:
        if verbose: print("    [L1] REJECT: Malformed packet (too short).")
        return None